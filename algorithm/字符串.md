学习笔记

#### 字符串分析算法
- 字典树：大量高重复字符串的存储与分析，例如一亿字符串中高频出现的部分字符串，搜索关键词。主要用于两个字符串是否完全匹配。
- KMP：长字符串中找模式，KMP属于部分匹配，一个字符串中是否存在另一个短字符串
- Wildcard：带通配符的字符串模式，比如问号匹配任意字符，星号匹配任意数量的任意字符
- 正则：字符串通用模式匹配（回溯？）
- 状态机：通用的字符串分析
- LL LR：字符串多层级结构分析

#### 字典树
顾名思义，就像字典一样一级一级往下找，通过切分单个字符实现。
设置一个符号为终结符（可以使用symbol），来判断是否对字符串完成切分。
每将一次字符串插入字典树中，可以利用终结符来计算重复的次数。
用来查询字符串的重复最大次数挺方便的。

#### KMP算法
KMP算法是对BF算法的一种改进。
BF算法比较好理解，比如有source字符串“ababe”和pattern字符串“abe“，分别从两个字符串的下标0开始判断。
1. source[0] === pattern[0]，都是a，相等，则继续匹配
2. source[1] === pattern[1]，都是b，相等，则继续匹配
3. source[2] !== pattern[2]，一个是a，一个是b，不相等，则从source的下标1，pattern的下标0开始匹配
4. 直到匹配到相同的字符串或者没有匹配到为止

可以看出这是一种暴力算法，没有对字符串的搜索进行任何的优化，对两个长度分别为m，n的字符串，BF算法的时间复杂度为O(mn)。
而KMP算法对BF算法进行改进，逻辑主要为：

1. 如果pattern字符串中不存在自重复的子字符串，那么直接让pattern从头开始匹配，仍旧以source字符串“ababe”和pattern字符串“abe“举例：
   当下标为2时，source[2]为“a”，pattern[2]为“e”，因为pattern之前的部分已经匹配过了，所以下一次匹配的时候，直接从pattern[0] 和 source[2]开始匹配。
2. 如果pattern字符串存在自重复的子字符串，这个重复的子字符串主要指一个子字符串中**「相等的」「最长的」的「前缀字符串」和「后缀字符串」**。
   比如，一个pattern字符串是“a b c d a b c d e”，当这个pattern和source匹配的时候，匹配到最后一位“e”的时候匹配不上了，但是我们知道了在“e”之前，都是匹配的。
   所以，找到这个字符串中「相等的」「最长的」的「前缀字符串」和「后缀字符串」，也就是“abcd”，（这里找公共的前缀后缀字符串的时候，去掉这个匹配的“e”，因为“e”在这里没有用）让第一个“abcd”移动到第二个“abcd”的位置，也就是让「前缀字符串」移动到「后缀字符串」的位置，这样就跳过了中间几个不必要的匹配。（当然这个移动是概念上的移动，实际上是改变了去访问下标的变量）。
3. 第二步是概念上的理解，也就是当我们自己去匹配字符串的时候，会比较直观地得到「前缀字符串」和「后缀字符串」，并将「前缀字符串」移动到「后缀字符串」的位置，而在代码中实现，则需要创建一个额外的、长度和pattern长度相等的数组，用来记录到当前下标为止，最长的公共前缀字符串和后缀字符串是多长。
   举例：“a b c d a b **c** d e”，最后得到的辅助数组为[ 0, 0, 0, 0, 0, 1, 2, 3, 4 ]，当匹配字符到第二“c”的时候，发现不再匹配，那么去查阅辅助数组，发现第二个“c”字符对应的下标为2，则从pattern数组的第二位开始匹配，相当于实现了「前缀字符串」移动到「后缀字符串」的位置。
4. 这个辅助数组如何实现，用两个变量去i=1，j=0开始遍历数组（因为重复至少是2位），如果pattern字符串中下标i与下标j相等，是最好的情况，i，j分别自增，然后将**最长重复子串的下标**记录到辅助数组中；如果pattern[i]和pattern[j]不相等，那么判断j是否大于0，如果不大于0，那么只增加i，继续遍历就行；如果j大于0，说明字符串中已经开始重复，让j回到辅助数组下标j的位置，是一个回溯的功能。



####Wildcard

引入了*号和？号的匹配。

关于\*号的匹配，可以将\*号分成三部分，第一个\*号，最后一个\*号和中间的\*号。其中最后的\*号可以将剩余字符全部匹配，因为是最后一个了；中间和第一个\*号考虑少匹配。